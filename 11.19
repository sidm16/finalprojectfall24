#define MAX_DIST 400.0
#define MAX_STEPS 128
#define THRESHOLD 0.01

#include "shapes.stoy"
#include "matrices.stoy"
#include "lygia/math/rotate3dX.glsl"
#include "lygia/generative/snoise.glsl"

struct Material {
    vec3 ambientColor;
    vec3 diffuseColor;
    vec3 specularColor;
    float alpha; // Shininess
};

struct Light {
    vec3 pos;
    vec3 color;
};

struct Surface {
    int id;
    float sd;
    Material mat;
};

Material birdMaterial() {
    vec3 baseColor = vec3(0.65, 0.4, 0.2); // Brownish
    return Material(0.2 * baseColor, 0.6 * baseColor,0.2 * vec3(1.0),16.0);
}

Material groundMaterial() {
    vec3 baseColor = vec3(0.85, 0.75, 0.6); // Desert/sand
    return Material(0.2 * baseColor,0.6 * baseColor,0.1 * vec3(1.0),8.0);
}

Material rockMaterial() {
    vec3 baseColor = vec3(0.4); // Dark gray rock
    return Material(0.2 * baseColor, 0.6 * baseColor, 0.1 * vec3(1.0), 8.0);
}

float smoothMin(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

Surface birdSDF(vec3 p) {
    float t = iTime;
    float dt = 0.01;
    float raise = 22.5;

    // Bird's position at time t
    vec3 birdPos = vec3(
        sin(t) * 10.0,
        raise + sin(t * 0.5) * 2.0,
        t * 5.0
    );

    // Bird's position at time t + dt
    vec3 birdPosNext = vec3(
        sin(t + dt) * 10.0,
        raise + sin((t + dt) * 0.5) * 2.0,
        (t + dt) * 5.0
    );

    // Flight direction
    vec3 dir = normalize(birdPosNext - birdPos);
    vec3 up = vec3(0.0, 1.0, 0.0);

    // Rotation matrix
    vec3 xAxis = dir;
    vec3 zAxis = normalize(cross(up, xAxis));
    vec3 yAxis = cross(zAxis, xAxis);
    mat3 birdRotation = mat3(xAxis, yAxis, zAxis);

    // Transform point to bird's space
    vec3 pLocal = birdRotation * (p - birdPos);

    // Body (Ellipsoid)
    vec3 bodyScale = vec3(1.0, 0.6, 0.6);
    float body = sdEllipsoid(pLocal / bodyScale, vec3(1.0));

    // Head (Sphere)
    float head = sphereSDF(pLocal - vec3(0.8, 0.3, 0.0), 0.3);

    // Beak (Cone along X-axis)
    float beak = sdConeX(pLocal - vec3(1.1, 0.3, 0.0), 0.0, 0.4, 0.1, 0.0);

    // Wings
    float wingFlap = sin(t * 6.5) * 0.4;

    // Left Wing
    vec3 leftWingP = pLocal - vec3(-0.2, 0.0, 0.6);
    mat3 leftWingRot = rotationY(0.2) * rotationX(wingFlap);
    leftWingP = leftWingRot * leftWingP;
    float leftWing = sdEllipsoid(leftWingP, vec3(0.6, 0.05, 0.3));

    // Right Wing
    vec3 rightWingP = pLocal - vec3(-0.2, 0.0, -0.6);
    mat3 rightWingRot = rotationY(-0.2) * rotationX(-wingFlap);
    rightWingP = rightWingRot * rightWingP;
    float rightWing = sdEllipsoid(rightWingP, vec3(0.6, 0.05, 0.3));

    // Combine all parts
    float bird = smoothMin(body, head, 0.2);
    bird = smoothMin(bird, beak, 0.1);
    bird = smoothMin(bird, leftWing, 0.1);
    bird = smoothMin(bird, rightWing, 0.1);

    return Surface(1, bird, birdMaterial());
}

Surface groundSDF(vec3 p) {
    float height = 0.0;
    height += snoise(p.xz * 0.02) * 15.0; // Large features
    height += snoise(p.xz * 0.1) * 5.0;   // Medium features
    height += snoise(p.xz * 0.5) * 2.0;   // Small features

    float ground = 0.1 * (p.y - height);

    return Surface(2, ground, groundMaterial());
}


Surface rockSDF(vec3 p) {
    vec3 size = vec3(1.0, 1.5, 1.0);
    vec3 pos = vec3(5.0, 0.0, 5.0);
    float d = boxSDF(p - pos, size);
    d -= 0.2* snoise((p - pos) * 2.0) * 0.3;

    return Surface(3, d, rockMaterial());
}


Surface scene(vec3 p) {
    Surface birdSurface = birdSDF(p);
    Surface groundSurface = groundSDF(p);
    Surface rockSurface = rockSDF(p);

    // Combine terrain and rock
    Surface terrainSurface;
    if(groundSurface.sd < rockSurface.sd)
    {
        terrainSurface = groundSurface;
    }
    else
    {
        terrainSurface = rockSurface;
    }
    // return terrainSurface;
    // Combine bird and terrain
    Surface finalSurface;
    if(birdSurface.sd < terrainSurface.sd)
    {
        finalSurface = birdSurface;
    }
    else
    {
        finalSurface = terrainSurface;;
    }

    return finalSurface;
}

vec3 calcNormal(vec3 p) {
    const float h = THRESHOLD * 2.0;
    vec3 n;
    n.x = scene(p + vec3(h, 0.0, 0.0)).sd - scene(p - vec3(h, 0.0, 0.0)).sd;
    n.y = scene(p + vec3(0.0, h, 0.0)).sd - scene(p - vec3(0.0, h, 0.0)).sd;
    n.z = scene(p + vec3(0.0, 0.0, h)).sd - scene(p - vec3(0.0, 0.0, h)).sd;
    return normalize(n);
}

float shadows(vec3 rayOrigin, Light light) {
    float d = THRESHOLD * 7.0;
    vec3 rayDir = normalize(light.pos - rayOrigin);
    float maxDist = length(light.pos - rayOrigin);
    float res = 1.0;

    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = rayOrigin + d * rayDir;
        float sd = scene(p).sd;
        if (sd < THRESHOLD) {
            return 0.0;
        }
        if (d >= maxDist) {
            break;
        }
        d += sd;
    }
    return res;
}

// float shadows(vec3 rayOrigin, Light light) {
//     vec3 rayDir = normalize(light.pos - rayOrigin);
//     float maxDist = length(light.pos - rayOrigin);
//     float d = THRESHOLD * 10.0;
//     for(int i = 0; i < MAX_STEPS; i++) {
//         if (d >= maxDist) {
//             return 1.0;
//         }
//         vec3 p = rayOrigin + d * rayDir;
//         float sd = scene(p).sd;
//         if(sd < THRESHOLD) {
//             return 0.0;
//         }
//         d += max(sd, THRESHOLD * 5.0);
//     }
//     return 1.0;
// }

vec3 phong(Light light, Material mat, vec3 p, vec3 normal, vec3 rayDir) {
    vec3 lightDir = normalize(light.pos - p);

    vec3 ambient = mat.ambientColor;

    float dotLN = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = mat.diffuseColor * dotLN;

    vec3 reflectDir = reflect(-lightDir, normal);
    float dotRV = max(dot(reflectDir, -rayDir), 0.0);
    vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);

    // Combine components
    vec3 color = ambient + diffuse + specular;
    return light.color * clamp(color, 0.0, 1.0) * 2.0;
}

Surface rayMarch(vec3 rayOrigin, vec3 rayDir) {
    float d = 0.0;
    Surface surf;

    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = rayOrigin + d * rayDir;
        surf = scene(p);
        if (surf.sd < THRESHOLD) {
            surf.sd = d;
            return surf;
        }
        d += surf.sd;
        if (d > MAX_DIST) {
            break;
        }
    }
    surf.sd = MAX_DIST;
    return surf;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    float t = iTime;
    float raise = 22.5;

    vec3 birdPos = vec3(sin(t) * 10.0,raise + sin(t * 0.5) * 2.0,t * 5.0);

    // Camera Setup
    vec3 cameraOffset = vec3(-30.0, 20.0, -30.0);
    vec3 cameraPos = birdPos + cameraOffset;
    vec3 cameraTarget = birdPos;
    vec3 cameraUp = vec3(0.0, 1.0, 0.0);
    float cameraFOV = radians(45.0);

    // Ray Setup
    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
    vec3 forward = normalize(cameraTarget - cameraPos);
    vec3 right = normalize(cross(forward, cameraUp));
    vec3 up = cross(right, forward);
    float focalLength = 1.0 / tan(cameraFOV * 0.5);
    vec3 rd = normalize(uv.x * right + uv.y * up + focalLength * forward);
    vec3 ro = cameraPos;

    // Ray Marching
    Surface surf = rayMarch(ro, rd);
    vec3 color = vec3(0.3, 0.5, 0.8); // Sky color

    if (surf.sd > MAX_DIST) {
        fragColor = vec4(color, 1.0);
        return;
    }

    // Lighting
    vec3 p = ro + rd * surf.sd;
    vec3 norm = calcNormal(p);

    Light light = Light(vec3(100.0, 200.0, 100.0), vec3(1.0, 0.9, 0.7));

    float shadow = shadows(p, light);
    vec3 phongColor = phong(light, surf.mat, p, norm, rd);
    color = phongColor * shadow;

    float circle = length(uv)-0.1;
    vec3 red = vec3(1.0, 0.0, 0.0);
    color = mix(color, red, step(circle, 0.0));
    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
}
